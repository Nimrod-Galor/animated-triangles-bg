<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        html, body{padding: 0; margin: 0;}
    </style>
    <script src="delaunay.js"></script>
    <title>Document</title>
</head>
<body>
    <canvas width="95" height="95" id="canvas"></canvas>

    <script type="text/javascript">
        window.addEventListener('resize', initScene);
        window.addEventListener('load', initScene);

        var fps = 30;
        var now;
        var then = Date.now();
        var interval = 1000/fps;
        var delta;
        var width;
        var height;
        var context;

        var agents = [];
        var triangles = [];

        function initScene(){
            width  = (window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth);
            height = (window.innerHeight|| document.documentElement.clientHeight|| document.body.clientHeight)  * 0.998;

            let canvas = document.getElementById("canvas");
            canvas.width = width;
            canvas.height = height;

            context = canvas.getContext("2d");

            agents = [
                new Point(0, 0, true),
                new Point(width * 0.3, 0, true),
                new Point(width * 0.6, 0, true),
                new Point(width, 0, true),
                new Point(width, height * 0.3, true),
                new Point(width, height * 0.6, true),
                new Point(width, height, true),
                new Point(width * 0.6, height, true),
                new Point(width * 0.3, height, true),
                new Point(0, height, true),
                new Point(0, height * 0.6, true),
                new Point(0, height * 0.3, true),
            ];

            for (let i = 0; i < 40; i++) {
                let x = Math.round( randomRange(0, width));
                let y = Math.round( randomRange(0, height));
                agents.push(new Point(x, y));
            }

            let points = [];
            agents.forEach((agent, index) => {
                points.push([agent.pos.x, agent.pos.y]);
            });

            let delaunay = new Delaunay(points);
            let trianglesArr = delaunay.triangulate();

            for(let i = 0; i <trianglesArr.length; i+=3){
                triangles.push(
                    new Triangle(
                        getAgent(trianglesArr[i]), 
                        getAgent(trianglesArr[i + 1]), 
                        getAgent(trianglesArr[i + 2]), 
                        rblue()
                    )
                );
            }

            animate();
        }

        function getAgent(p){
            for(let i=0; i<agents.length;i++){
                if(agents[i].pos.x == p[0] && agents[i].pos.y == p[1]){
                    console.log("IN");
                    return agents[i];
                }
            };
        }

        const animate = () => {
            now = Date.now();
            delta = now - then;
            
            if (delta > interval) {
                then = now - (delta % interval);
                for(let i=0; i < triangles.length; i++){
                    context.beginPath();
                    context.moveTo(triangles[i].p1.pos.x, triangles[i].p1.pos.y);
                    context.lineTo(triangles[i].p2.pos.x, triangles[i].p2.pos.y);
                    context.lineTo(triangles[i].p3.pos.x, triangles[i].p3.pos.y);
                    context.closePath();
                    context.stroke(); 
                    context.fillStyle = triangles[i].color;
                    context.fill(); 

                    if(triangles[i].areaBounce() < 250){
                        if(!triangles[i].p1.static){
                            //let a = calcangle()
                            triangles[i].p1.vel.x *= -1;
                            triangles[i].p1.vel.y *= -1;
                        }
                        if(!triangles[i].p2.static){
                            triangles[i].p2.vel.x *= -1;
                            triangles[i].p2.vel.y *= -1;
                        }
                        if(!triangles[i].p3.static){
                            triangles[i].p3.vel.x *= -1;
                            triangles[i].p3.vel.y *= -1;
                        }
                    }
                }

                for(let i = 12; i < agents.length; i++){
                    agents[i].update();
                    agents[i].bounce();
                }
            }
            requestAnimationFrame(animate);
        }

        /*function calcangle(ax,ay,bx,by,cx,cy,dx,dy) {
            let dx0  = bx - ax;
            let dy0  = by - ay;
            let dx1  = x11 - cx;
            let dy1  = dy - cy;
            let angle = Math.atan2(dx0 * dy1 - dx1 * dy0, dx0 * dx1 + dy0 * dy1);
            //writeln(angle);
            //writeln(angle*180/3.1415926);
            return angle;
        }*/

        function rblue(){
            let h = 240;
            //let s = Math.floor(Math.random() * 50);
            let s = Math.floor(randomRange(40, 50));
            //let l = Math.floor(Math.random() * 30);
            let l = Math.floor(randomRange(30, 40));
            let color = 'hsl(' + h + ', ' + s + '%, ' + l + '%)';
            return color;
        }

        function randomRange(min, max){
            return Math.random() * (max - min) + min;
        }

        class Vector {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
        }

        class Point {
            constructor(x, y, s=false) {
                this.pos = new Vector(x, y);
                this.vel = new Vector(randomRange(-1, 1), randomRange(-1, 1));
                this.static = s;
            }

            bounce() {
                if (this.pos.x <= 0 || this.pos.x >= width)  this.vel.x *= -1;
                if (this.pos.y <= 0 || this.pos.y >= height) this.vel.y *= -1;
            }

            update() {
                this.pos.x += this.vel.x * 0.1;
                this.pos.y += this.vel.y * 0.1;
            }

        }

        class Triangle{
            constructor(_p1, _p2, _p3, _color){
                this.p1 = _p1;
                this.p2 = _p2;
                this.p3 = _p3;
                this.color = _color;
            }

            areaBounce(){
                let area =1/2 * (this.p1.pos.x * (this.p2.pos.y - this.p3.pos.y) + this.p2.pos.x * (this.p3.pos.y - this.p1.pos.y) + this.p3.pos.x * (this.p1.pos.y - this.p2.pos.y));
                return area;
            }
        }

        /*

        const animate = () => {
            context.fillStyle = 'white';
            context.fillRect(0, 0, width, height);

            for(let x = 0; x < linesDrawn.length; x++){
                context.beginPath();
                context.strokeStyle = "#FF0000";
                context.moveTo(linesDrawn[x].v1.pos.x, linesDrawn[x].v1.pos.y);
                context.lineTo(linesDrawn[x].v2.pos.x, linesDrawn[x].v2.pos.y);
                context.stroke();
            }

            agents.forEach((agent, index) => {
                agent.update();
                agent.draw(context);
                agent.bounce(width, height);
            });

            //check lines intersection (bounce)
            for(let x = 0; x < linesDrawn.length; x++){
                for(let y = 0; y < linesDrawn.length; y++){
                    if(linesDrawn[x].v1 == linesDrawn[y].v2 || linesDrawn[x].v2 == linesDrawn[y].v1){
                        continue;
                    }
                    if(intersects(linesDrawn[x].v1.pos.x, linesDrawn[x].v1.pos.y, linesDrawn[x].v2.pos.x, linesDrawn[x].v2.pos.y, linesDrawn[y].v1.pos.x, linesDrawn[y].v1.pos.y, linesDrawn[y].v2.pos.x, linesDrawn[y].v2.pos.y)){
                        let intersectionPoint = lineLineIntersection(linesDrawn[x].v1.pos, linesDrawn[x].v2.pos, linesDrawn[y].v1.pos, linesDrawn[y].v2.pos);
                        let closestPoint = [linesDrawn[x].v1, linesDrawn[x].v2, linesDrawn[y].v1, linesDrawn[y].v2].reduce((a, b) => a.pos.getDistance(b.pos) ? a : b);
                        closestPoint.vel.x *= -1;
                        closestPoint.vel.y *= -1;
                    }
                }
            }
            
            requestAnimationFrame(animate)
        }

        function lineLineIntersection(A, B, C, D){
            // Line AB represented as a1x + b1y = c1
            let a1 = B.y - A.y;
            let b1 = A.x - B.x;
            let c1 = a1*(A.x) + b1*(A.y);

            // Line CD represented as a2x + b2y = c2
            let a2 = D.y - C.y;
            let b2 = C.x - D.x;
            let c2 = a2*(C.x)+ b2*(C.y);

            let determinant = a1*b2 - a2*b1;

            if (determinant == 0){
                // The lines are parallel. This is simplified
                // by returning a pair of FLT_MAX
                //return make_pair(FLT_MAX, FLT_MAX);
            }else{
                let x = (b2*c1 - b1*c2)/determinant;
                let y = (a1*c2 - a2*c1)/determinant;
                return new Vector(x, y);
            }
        }


        function initScene(){
            width  = (window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth)  * 0.997;
            height = (window.innerHeight|| document.documentElement.clientHeight|| document.body.clientHeight)  * 0.997;

            let canvas = document.getElementById("canvas");
            canvas.width = width;
            canvas.height = height;

            context = canvas.getContext("2d");

            // init agents
            agents = [
                new Agent(0, 0, 0),
                new Agent(width * 0.3, 0, 1),
                new Agent(width * 0.6, 0, 2),
                new Agent(width, 0, 3),
                new Agent(width, height * 0.5, 4),
                new Agent(width, height, 5),
                new Agent(width * 0.6, height, 6),
                new Agent(width * 0.3, height, 7),
                new Agent(0, height, 8),
                new Agent(0, height * 0.6, 9),
                new Agent(0, height * 0.3, 10),
            ];

            for (let i = 0; i < 40; i++) {
                const x = randomRange(0, width);
                const y = randomRange(0, height);

                agents.push(new Agent(x, y, i + 11));
            }

            // set triangle side
            linesDrawn = [];
            for (let i = 0; i < agents.length; i++) {
                let agent = agents[i];

                for (let j = i + 1; j < agents.length; j++) {
                    let other = agents[j];

                    // check intersection
                    let intersectionFlag = false;
                    
                    for(let x = 0; x< agents.length; x++){
                        const xPos = agents[x];
                        for(let z = 0; z < agents.length; z++){
                            const zPos = agents[z];
                            if(agent == xPos || agent == zPos || other == xPos || other == zPos || xPos == zPos){
                                continue;
                            }

                            if(intersects(agent.pos.x, agent.pos.y, other.pos.x, other.pos.y, xPos.pos.x, xPos.pos.y, zPos.pos.x, zPos.pos.y)){
                                let dist1 = agent.pos.getDistance(other.pos);
                                let dist2 = xPos.pos.getDistance(zPos.pos);
                                if(dist1 <= dist2){
                                    continue;
                                }
                                intersectionFlag = true;
                                break;
                            }

                        }
                        if(intersectionFlag){
                            break;
                        }
                    }

                    if(!intersectionFlag){
                        linesDrawn.push({"v1": agent, "v2": other});
                    }
                }
            }

            for (let i = 0; i < agents.length; i++) {
                let agent = agents[i];

                for (let j = i + 1; j < agents.length; j++) {
                    let other = agents[j];

                    // check intersection
                    let intersectionFlag = false;
                    for(let x = 0; x < linesDrawn.length; x++){
                        if(agent == linesDrawn[x].v1 && other == linesDrawn[x].v2){
                            continue;
                        }

                        if(intersects(agent.pos.x, agent.pos.y, other.pos.x, other.pos.y, linesDrawn[x].v1.pos.x, linesDrawn[x].v1.pos.y, linesDrawn[x].v2.pos.x, linesDrawn[x].v2.pos.y)){
                            intersectionFlag = true;
                            break;
                        }
                    }

                    if(!intersectionFlag){
                        linesDrawn.push({"v1": agent, "v2": other});
                    }
                }

            }

            animate();
        }

        

        function mapRange(value, low1, high1, low2, high2) {
            return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
        }

        function intersects(a,b,c,d,p,q,r,s) {
            var det, gamma, lambda;
            det = (c - a) * (s - q) - (r - p) * (d - b);
            if (det === 0) {
                return false;
            } else {
                lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
                gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
                return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
            }
        }

        
        */
        
        
    </script>
</body>
</html>