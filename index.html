<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        html, body{padding: 0; margin: 0;}
    </style>
    <script src="delaunay.js"></script>
    <title>Document</title>
</head>
<body>
    <canvas width="95" height="95" id="canvas"></canvas>

    <script type="text/javascript">
        window.addEventListener('resize', initScene);
        window.addEventListener('load', initScene);

        var fps = 30;
        var now;
        var then = Date.now();
        var interval = 1000/fps;
        var delta;
        var width;
        var height;
        var context;

        var agents = [];
        var triangles = [];

        function initScene(){
            width  = (window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth);
            height = (window.innerHeight|| document.documentElement.clientHeight|| document.body.clientHeight)  * 0.998;

            let canvas = document.getElementById("canvas");
            canvas.width = width;
            canvas.height = height;

            context = canvas.getContext("2d");

            agents = [
                new Point(0, 0, true),
                new Point(width * 0.3, 0, true),
                new Point(width * 0.6, 0, true),
                new Point(width, 0, true),
                new Point(width, height * 0.3, true),
                new Point(width, height * 0.6, true),
                new Point(width, height, true),
                new Point(width * 0.6, height, true),
                new Point(width * 0.3, height, true),
                new Point(0, height, true),
                new Point(0, height * 0.6, true),
                new Point(0, height * 0.3, true),
            ];

            for (let i = 0; i < 40; i++) {
                let x = randomRange(0, width);
                let y = randomRange(0, height);
                agents.push(new Point(x, y));
            }

            let points = [];
            agents.forEach((agent, index) => {
                points.push([agent.pos.x, agent.pos.y]);
            });

            let delaunay = new Delaunay(points);
            let trianglesArr = delaunay.triangulate();

            for(let i = 0; i <trianglesArr.length; i+=3){
                triangles.push(
                    new Triangle(
                        getAgent(trianglesArr[i]), 
                        getAgent(trianglesArr[i + 1]), 
                        getAgent(trianglesArr[i + 2]), 
                        rblue()
                    )
                );
            };

            animate();
        }

        function getAgent(p){
            for(let i=0; i<agents.length;i++){
                if(agents[i].pos.x == p[0] && agents[i].pos.y == p[1]){
                    console.log("IN");
                    return agents[i];
                }
            };
        }

        const animate = () => {
            now = Date.now();
            delta = now - then;
            
            if (delta > interval) {
                then = now - (delta % interval);
                for(let i=0; i < triangles.length; i++){
                    context.beginPath();
                    context.moveTo(triangles[i].p1.pos.x, triangles[i].p1.pos.y);
                    context.lineTo(triangles[i].p2.pos.x, triangles[i].p2.pos.y);
                    context.lineTo(triangles[i].p3.pos.x, triangles[i].p3.pos.y);
                    context.closePath();
                    context.stroke(); 
                    context.fillStyle = triangles[i].color;
                    context.fill(); 

                    if(triangles[i].areaBounce() <= 50){
                        let bouncPoint = {p1:Number.MAX_VALUE, p2:Number.MAX_VALUE, p3:Number.MAX_VALUE};
                        if(!triangles[i].p1.static){
                            //bouncPoint.p1 = minDistance( triangles[i].p2.pos,  triangles[i].p3.pos,  triangles[i].p1.pos);
                            triangles[i].p1.vel.x *= -1;
                            triangles[i].p1.vel.y *= -1;
                        }
                        if(!triangles[i].p2.static){
                            //bouncPoint.p2 = minDistance( triangles[i].p1.pos,  triangles[i].p3.pos,  triangles[i].p2.pos);
                            triangles[i].p2.vel.x *= -1;
                            triangles[i].p2.vel.y *= -1;
                        }
                        if(!triangles[i].p3.static){
                            //bouncPoint.p3 = minDistance( triangles[i].p2.pos,  triangles[i].p1.pos,  triangles[i].p3.pos);
                            triangles[i].p3.vel.x *= -1;
                            triangles[i].p3.vel.y *= -1;
                        }
/*
                        let minDist = Math.min(bouncPoint.p1, bouncPoint.p2, bouncPoint.p3);
//console.log(JSON.stringify(bouncPoint) + " min: " + minDist);
                        if(minDist == bouncPoint.p1){
                            bouncePoint(triangles[i].p2,  triangles[i].p3,  triangles[i].p1);
                            triangles[i].color = "red";
                            //triangles[i].p1.vel.x = newVel.x;
                            //triangles[i].p1.vel.y = newVel.y;
                        }else if(minDist == bouncPoint.p2){
                            bouncePoint(triangles[i].p1,  triangles[i].p3,  triangles[i].p2);
                            triangles[i].color = "green";
                            //triangles[i].p2.vel.x = newVel.x;
                            //triangles[i].p2.vel.y = newVel.y;
                        }else if(minDist == bouncPoint.p3){
                            bouncePoint(triangles[i].p2,  triangles[i].p1,  triangles[i].p3);
                            triangles[i].color = "blue";
                            //triangles[i].p3.vel.x = newVel.x;
                            //triangles[i].p3.vel.y = newVel.y;
                        }else{
                            console.log("FFFFFFF")
                        }
                        */
                    }
                }

                for(let i = 12; i < agents.length; i++){
                    agents[i].update();
                    agents[i].bounce();
                }
            }
            requestAnimationFrame(animate);
        }

        // return angle between a velocity (particles motion) and a line
        // between a line segment AB and a point E
        function bouncePoint(A, B, C){
            //let Vecn = normal(A.pos);//(-y/sqrt(x*x+y*y), x/sqrt(x*x+y*y))
            //let b = bounce(Vecn, C.vel);
//console.log(JSON.stringify(b));

            C.vel.x *= -1;//b.x;
            C.vel.y *= -1;//b.y;

            //let slope = (B.pos.y - A.pos.y) / (B.pos.x - A.pos.x);
            /*var angleDeg = Math.atan2((B.pos.y - A.pos.y), (B.pos.x - A.pos.x)) * 180 / Math.PI;
            let nx = -Math.sin(angleDeg);
            let ny = Math.cos(angleDeg);
            let dot = C.vel.x * nx + C.vel.y * ny;
            let vnewx = C.vel.x - 2 * dot * nx;
            let vnewy = C.vel.y - 2 * dot * ny;
console.log("angleDeg:" + angleDeg + " nx:" + nx + " ny:" + ny);
            C.vel.x = vnewx;
            C.vel.y = vnewy;
//console.log(JSON.stringify(C));
*/
        }




        function bounce(Vecn, Vecv){
            let tmp = scalarMultiply(-2 * dot(Vecn,Vecv), Vecn);
            return sub(Vecv, tmp);
        }

        //function dot(Veca, Vecb) {
        function dot(Veca, Vecb) {
            return Veca.x * Vecb.x + Veca.y * Vecb.y; // + a.z*b.z if you're in 3D
        }

        function scalarMultiply(multi, Vecn){
            let new_vector = {x:Vecn.x * multi, y:Vecn.y * multi};
            return new_vector;
        }

        function normal(vec){
            var length = Math.sqrt(vec.x * vec.x + vec.y * vec.y); //calculating length
            let x = vec.x / length; //assigning new value to x (dividing x by length of the vector)
            let y= vec.y / length; //assigning new value to y
            return {x:x, y:y};
        }

        function add(vecA, vecB){
            return {x: vecA.x + vecB.x, y: vecA.y + vecB.y};
        }

        function sub(vecA, vecB){
            return {x: vecA.x - vecB.x, y: vecA.y - vecB.y};
        }

        // Function to return the minimum distance
        // between a line segment AB and a point E
        function minDistance( A,  B,  E){
            // vector AB
            var AB = {x: (B.x - A.x), y: (B.y - A.y)};
        
            // vector BP
            var BE ={x: (E.x - B.x), y: (E.y - B.y)};
        
            // vector AP
            var AE = {x: (E.x - A.x), y: (E.y -A.y)};
        
            // Variables to store dot product
            var AB_BE, AB_AE;
        
            // Calculating the dot product
            AB_BE = (AB.x * BE.x + AB.y * BE.y);
            AB_AE = (AB.x * AE.x + AB.y * AE.y);
        
            // Minimum distance from
            // point E to the line segment
            var reqAns = 0;
        
            // Case 1
            if (AB_BE > 0) {
        
                // Finding the magnitude
                var y = E.y - B.x;
                var x = E.x - B.x;
                reqAns = Math.sqrt(x * x + y * y);
            }
        
            // Case 2
            else if (AB_AE < 0) {
                var y = E.y - A.y;
                var x = E.x - A.x;
                reqAns = Math.sqrt(x * x + y * y);
            }
        
            // Case 3
            else {// Finding the perpendicular distance
                var x1 = AB.x;
                var y1 = AB.y;
                var x2 = AE.x;
                var y2 = AE.y;
                var mod = Math.sqrt(x1 * x1 + y1 * y1);
                reqAns = Math.abs(x1 * y2 - y1 * x2) / mod;
            }
            return Math.round(reqAns);
        }

        /*function calcangle(ax,ay,bx,by,cx,cy,dx,dy) {
            let dx0  = bx - ax;
            let dy0  = by - ay;
            let dx1  = x11 - cx;
            let dy1  = dy - cy;
            let angle = Math.atan2(dx0 * dy1 - dx1 * dy0, dx0 * dx1 + dy0 * dy1);
            //writeln(angle);
            //writeln(angle*180/3.1415926);
            return angle;
        }*/

        function rblue(){
            let h = 240;
            //let s = Math.floor(Math.random() * 50);
            let s = Math.floor(randomRange(40, 50));
            //let l = Math.floor(Math.random() * 30);
            let l = Math.floor(randomRange(30, 40));
            let color = 'hsl(' + h + ', ' + s + '%, ' + l + '%)';
            return color;
        }

        function randomRange(min, max){
            return Math.random() * (max - min) + min;
        }

        class Vector {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
        }

        class Point {
            constructor(x, y, s=false) {
                this.pos = new Vector(x, y);
                this.vel = new Vector(randomRange(-10, 10), randomRange(-10, 10));
                this.static = s;
            }

            bounce() {
                if (this.pos.x <= 0 || this.pos.x >= width)  this.vel.x *= -1;
                if (this.pos.y <= 0 || this.pos.y >= height) this.vel.y *= -1;
            }

            update() {
                this.pos.x += this.vel.x * 0.1;
                this.pos.y += this.vel.y * 0.1;
            }

        }

        class Triangle{
            constructor(_p1, _p2, _p3, _color){
                this.p1 = _p1;
                this.p2 = _p2;
                this.p3 = _p3;
                this.color = _color;
            }

            areaBounce(){
                let area =1/2 * (this.p1.pos.x * (this.p2.pos.y - this.p3.pos.y) + this.p2.pos.x * (this.p3.pos.y - this.p1.pos.y) + this.p3.pos.x * (this.p1.pos.y - this.p2.pos.y));
                return area;
            }
        }

        /*

        const animate = () => {
            context.fillStyle = 'white';
            context.fillRect(0, 0, width, height);

            for(let x = 0; x < linesDrawn.length; x++){
                context.beginPath();
                context.strokeStyle = "#FF0000";
                context.moveTo(linesDrawn[x].v1.pos.x, linesDrawn[x].v1.pos.y);
                context.lineTo(linesDrawn[x].v2.pos.x, linesDrawn[x].v2.pos.y);
                context.stroke();
            }

            agents.forEach((agent, index) => {
                agent.update();
                agent.draw(context);
                agent.bounce(width, height);
            });

            //check lines intersection (bounce)
            for(let x = 0; x < linesDrawn.length; x++){
                for(let y = 0; y < linesDrawn.length; y++){
                    if(linesDrawn[x].v1 == linesDrawn[y].v2 || linesDrawn[x].v2 == linesDrawn[y].v1){
                        continue;
                    }
                    if(intersects(linesDrawn[x].v1.pos.x, linesDrawn[x].v1.pos.y, linesDrawn[x].v2.pos.x, linesDrawn[x].v2.pos.y, linesDrawn[y].v1.pos.x, linesDrawn[y].v1.pos.y, linesDrawn[y].v2.pos.x, linesDrawn[y].v2.pos.y)){
                        let intersectionPoint = lineLineIntersection(linesDrawn[x].v1.pos, linesDrawn[x].v2.pos, linesDrawn[y].v1.pos, linesDrawn[y].v2.pos);
                        let closestPoint = [linesDrawn[x].v1, linesDrawn[x].v2, linesDrawn[y].v1, linesDrawn[y].v2].reduce((a, b) => a.pos.getDistance(b.pos) ? a : b);
                        closestPoint.vel.x *= -1;
                        closestPoint.vel.y *= -1;
                    }
                }
            }
            
            requestAnimationFrame(animate)
        }

        function lineLineIntersection(A, B, C, D){
            // Line AB represented as a1x + b1y = c1
            let a1 = B.y - A.y;
            let b1 = A.x - B.x;
            let c1 = a1*(A.x) + b1*(A.y);

            // Line CD represented as a2x + b2y = c2
            let a2 = D.y - C.y;
            let b2 = C.x - D.x;
            let c2 = a2*(C.x)+ b2*(C.y);

            let determinant = a1*b2 - a2*b1;

            if (determinant == 0){
                // The lines are parallel. This is simplified
                // by returning a pair of FLT_MAX
                //return make_pair(FLT_MAX, FLT_MAX);
            }else{
                let x = (b2*c1 - b1*c2)/determinant;
                let y = (a1*c2 - a2*c1)/determinant;
                return new Vector(x, y);
            }
        }


        function initScene(){
            width  = (window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth)  * 0.997;
            height = (window.innerHeight|| document.documentElement.clientHeight|| document.body.clientHeight)  * 0.997;

            let canvas = document.getElementById("canvas");
            canvas.width = width;
            canvas.height = height;

            context = canvas.getContext("2d");

            // init agents
            agents = [
                new Agent(0, 0, 0),
                new Agent(width * 0.3, 0, 1),
                new Agent(width * 0.6, 0, 2),
                new Agent(width, 0, 3),
                new Agent(width, height * 0.5, 4),
                new Agent(width, height, 5),
                new Agent(width * 0.6, height, 6),
                new Agent(width * 0.3, height, 7),
                new Agent(0, height, 8),
                new Agent(0, height * 0.6, 9),
                new Agent(0, height * 0.3, 10),
            ];

            for (let i = 0; i < 40; i++) {
                const x = randomRange(0, width);
                const y = randomRange(0, height);

                agents.push(new Agent(x, y, i + 11));
            }

            // set triangle side
            linesDrawn = [];
            for (let i = 0; i < agents.length; i++) {
                let agent = agents[i];

                for (let j = i + 1; j < agents.length; j++) {
                    let other = agents[j];

                    // check intersection
                    let intersectionFlag = false;
                    
                    for(let x = 0; x< agents.length; x++){
                        const xPos = agents[x];
                        for(let z = 0; z < agents.length; z++){
                            const zPos = agents[z];
                            if(agent == xPos || agent == zPos || other == xPos || other == zPos || xPos == zPos){
                                continue;
                            }

                            if(intersects(agent.pos.x, agent.pos.y, other.pos.x, other.pos.y, xPos.pos.x, xPos.pos.y, zPos.pos.x, zPos.pos.y)){
                                let dist1 = agent.pos.getDistance(other.pos);
                                let dist2 = xPos.pos.getDistance(zPos.pos);
                                if(dist1 <= dist2){
                                    continue;
                                }
                                intersectionFlag = true;
                                break;
                            }

                        }
                        if(intersectionFlag){
                            break;
                        }
                    }

                    if(!intersectionFlag){
                        linesDrawn.push({"v1": agent, "v2": other});
                    }
                }
            }

            for (let i = 0; i < agents.length; i++) {
                let agent = agents[i];

                for (let j = i + 1; j < agents.length; j++) {
                    let other = agents[j];

                    // check intersection
                    let intersectionFlag = false;
                    for(let x = 0; x < linesDrawn.length; x++){
                        if(agent == linesDrawn[x].v1 && other == linesDrawn[x].v2){
                            continue;
                        }

                        if(intersects(agent.pos.x, agent.pos.y, other.pos.x, other.pos.y, linesDrawn[x].v1.pos.x, linesDrawn[x].v1.pos.y, linesDrawn[x].v2.pos.x, linesDrawn[x].v2.pos.y)){
                            intersectionFlag = true;
                            break;
                        }
                    }

                    if(!intersectionFlag){
                        linesDrawn.push({"v1": agent, "v2": other});
                    }
                }

            }

            animate();
        }

        

        function mapRange(value, low1, high1, low2, high2) {
            return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
        }

        function intersects(a,b,c,d,p,q,r,s) {
            var det, gamma, lambda;
            det = (c - a) * (s - q) - (r - p) * (d - b);
            if (det === 0) {
                return false;
            } else {
                lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
                gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
                return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
            }
        }

        
        */
        
        
    </script>
</body>
</html>